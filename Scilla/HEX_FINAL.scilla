scilla_version 0

import BoolUtils IntUtils

library HashSwap

type Denom =
  | Husd of ByStr20 (* husd address *)
  | Token of ByStr20 (* token address / hash *)
type Coins = | Coins of Denom Uint128 (* denom, amount *)
type Pool = | Pool of Uint128 Uint128 (* x, y = husd reserve, token reserve *)
type StakingReward = | StakingReward of Uint128 BNum (* Stakig Reward, Last Staking Reward Block *)
type Reward = | Reward of Uint128 StakingReward BNum (* Transaction Fee, Staking Reward, Pool Creation Block *)

let price_denom = Uint256 100 (* fee denominated in basis points (1 b.p. = 0.01%) *)

type SwapDirection = | HusdToToken | TokenToHusd
type ExactSide = | ExactInput | ExactOutput
type Swap = | Swap of (Option Pool) SwapDirection ExactSide Uint128 (Option Uint128) Uint256 
(* exact amt, limit amt, after fee amt *)
type ResultOrError =
 | Result of Pool Uint128 (* unwrapped pool, calculated amount *)
 | Error of String

let zero = Uint128 0
let one = Uint128 1
let true: Bool = True
let false: Bool = False
let zeroAddress: ByStr20 = 0x0000000000000000000000000000000000000000

let min_liquidity = Uint128 1000000000000000 (* 1000 HUSD *)
let fee_denom = Uint256 10000 (* fee denominated in basis points (1 b.p. = 0.01%) *)
let husd_address = 0x092538858d508332b010fc16e4f07f4e3e27c7a5
let husd = Husd husd_address

let oneMsg : Message -> List Message =
  fun (msg : Message) =>
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

let grow : Uint128 -> Uint256 =
  fun (var : Uint128) =>
    let maybe_big = builtin to_uint256 var in
    match maybe_big with
    | Some big => big
    | None => Uint256 0 (* should never happen *)
    end


let ratio : Uint128 -> Uint128 -> Option Uint128 = 
  fun (n : Uint128) =>
  fun (d : Uint128) =>
    let big_n = grow n in
    let big_d = grow d in 
    let n_over_d = builtin div big_n big_d in
    builtin to_uint128 n_over_d
  
  
(* computes the amount of the fraction x / d that is in y *)
(* result = yd/x *)
let frac : Uint128 -> Uint128 -> Uint128 -> Option Uint128  =
  fun (d : Uint128) =>
  fun (x : Uint128) =>
  fun (y : Uint128) =>
    let big_x = grow x in
    let big_y = grow y in
    let big_d = grow d in
    let d_times_y = builtin mul big_d big_y in
    let d_times_y_over_x = builtin div d_times_y big_x in
    builtin to_uint128 d_times_y_over_x

let frac256 : Uint128 -> Uint256 -> Uint256 -> Option Uint128  =
  fun (a : Uint128) =>
  fun (d : Uint256) =>
  fun (k : Uint256) =>
    let big_a = grow a in
    let a_times_k = builtin mul big_a k in
    let a_times_k_over_d = builtin div a_times_k d in
    builtin to_uint128 a_times_k_over_d


(* computes the husd that should be taken from the husd reserve
    when the given token amount is added to the token reserve *)
(* i = Husd Amount Output
   i' = i*10000/k Before Fee Husd Output
   xy = (x-i')(y+d) 
   => i' = xd/(y+d) Before Fee Husd
   => i = i'k/10000  Exact Husd
   => i = xdk/10000*(y+d)
   k is after_fee = 9997 types
   10000 is fee denom
   i = after fee input amount *) 
let outputHusdForExactInputToken : Uint128 -> Uint128 -> Uint128 -> Uint256 -> Option Uint128 =
  fun (token_amount_u128 : Uint128) =>
  fun (token_reserve_u128 : Uint128) =>
  fun (husd_reserve_u128 : Uint128) =>
  fun (after_fee : Uint256) =>
    let token_amount = grow token_amount_u128 in
    let token_reserve = grow token_reserve_u128 in
    let husd_reserve = grow husd_reserve_u128 in
    let token_amount_after_fee = builtin mul token_amount after_fee in (* dk *)
    let numerator = builtin mul husd_reserve token_amount_after_fee in (* xdk *)
    let denominator = 
      let d1 = builtin add token_reserve token_amount in (* y+d *)
      builtin mul d1 fee_denom in (* 10000*(y+d) *)
    let result = builtin div numerator denominator in
    builtin to_uint128 result

(* computes the token that should be added to token reserve
when given amount of husd should be taken from Husd reserve *)
(* i = Husd Amount Output
   i' = i*10000/k Before Fee Husd Output
   xy = (x-i')(y+d) 
   => d = i'y/(x-i')
   => d = yi*10000/(xk-i*10000)
   i = husd_amount to be taken out *) 
let inputTokenForExactOutputHusd : Uint128 -> Uint128 -> Uint128 -> Uint256 -> Option Uint128 =
  fun (husd_amount_u128 : Uint128) =>
  fun (token_reserve_u128 : Uint128) =>
  fun (husd_reserve_u128 : Uint128) =>
  fun (after_fee : Uint256) =>
    let husd_amount = grow husd_amount_u128 in
    let token_reserve = grow token_reserve_u128 in
    let husd_reserve = grow husd_reserve_u128 in
    let husd_amount_before_fee = builtin mul husd_amount fee_denom in (* i*10000 *)
    let numerator = builtin mul token_reserve husd_amount_before_fee in (* yi*10000 *)
    let denominator = 
      let d1 = builtin add husd_reserve after_fee in (* xk *)
      builtin sub d1 husd_amount_before_fee in (* xk - i*10000 *)
    let result = builtin div numerator denominator in
    builtin to_uint128 result


(* computes the husd that should be taken from the husd reserve
    when the given token amount is added to the token reserve *)
(* i = Husd Amount Input
   i' = ik/10000 After fee Husd Input
   xy = (x+i')(y-d) 
   => d = i'y/(x+i')
   => d = iky/(x*10000+ik)
   k is after_fee = 9997 types
   10000 is fee denom
   i = after fee input amount *) 
let outputTokenForExactInputHusd : Uint128 -> Uint128 -> Uint128 -> Uint256 -> Option Uint128 =
  fun (husd_amount_u128 : Uint128) =>
  fun (token_reserve_u128 : Uint128) =>
  fun (husd_reserve_u128 : Uint128) =>
  fun (after_fee : Uint256) =>
    let husd_amount = grow husd_amount_u128 in
    let token_reserve = grow token_reserve_u128 in
    let husd_reserve = grow husd_reserve_u128 in
    let husd_amount_after_fee = builtin mul husd_amount after_fee in (* ik *)
    let numerator = builtin mul token_reserve husd_amount_after_fee in (* iky *)
    let denominator = 
      let d1 = builtin mul husd_reserve fee_denom in (* x*100000 *)
      builtin add d1 husd_amount_after_fee in (* x*10000 + ik *)
    let result = builtin div numerator denominator in
    builtin to_uint128 result


(* computes the husd that should be taken from the husd reserve
    when the given token amount is added to the token reserve *)
(* i = Husd Amount Input
   i' = ik/10000 After fee Husd Input
   xy = (x+i')(y-d) 
   => i' = xd/(y-d)
   => i = xd*10000/k(y-d)
   k is after_fee = 9997 types
   10000 is fee denom
   i = after fee input amount *) 
let inputHusdForExactOutputToken : Uint128 -> Uint128 -> Uint128 -> Uint256 -> Option Uint128 =
  fun (token_amount_u128 : Uint128) =>
  fun (token_reserve_u128 : Uint128) =>
  fun (husd_reserve_u128 : Uint128) =>
  fun (after_fee : Uint256) =>
    let token_amount = grow token_amount_u128 in
    let token_reserve = grow token_reserve_u128 in
    let husd_reserve = grow husd_reserve_u128 in
    let token_amount_before_fee = builtin mul token_amount fee_denom in (* d*10000 *)
    let numerator = builtin mul husd_reserve token_amount_before_fee in
    let denominator = (* k(y-d) *)
      let d1 = builtin sub token_reserve token_amount in
      builtin mul d1 after_fee in
    let result = builtin div numerator denominator in
    builtin to_uint128 result


(* computes the corresponding input or output amount for
   the given exact output or input amount, pool, and direction *)
let amountFor : Pool -> SwapDirection -> ExactSide -> Uint128 -> Uint256 -> Option Uint128 =
  fun (pool : Pool) =>
  fun (swap_direction : SwapDirection) =>
  fun (exact_side : ExactSide) =>
  fun (exact_amount : Uint128) =>
  fun (after_fee : Uint256) =>
    match pool with
    | Pool husd_reserve token_reserve =>
      let calc = 
      fun (swap : SwapDirection) =>
      fun (exact: ExactSide) =>
      match exact with
      | ExactInput => 
        match swap with
        | HusdToToken => outputTokenForExactInputHusd
        | TokenToHusd => outputHusdForExactInputToken
        end
      | ExactOutput => 
        match swap with
        | HusdToToken => inputHusdForExactOutputToken
        | TokenToHusd => inputTokenForExactOutputHusd
        end
      end in
      calc swap_direction exact_side exact_amount token_reserve husd_reserve after_fee
    end

(* checks whether the result amount is within the user provided
   limit amount, which is dependent on whether the output or input
   result was the one being computed *)
   
(* If Input is fixed : Output > Limit *)
(* If Output is fixed : Input < Limit *)
let withinLimits : Uint128 -> Option Uint128 -> ExactSide -> Bool =
  fun (result_amount : Uint128) =>
  fun (maybe_limit_amount : Option Uint128) =>
  fun (exact_side : ExactSide) =>
    match maybe_limit_amount with
    | None => True
    | Some limit_amount =>
      match exact_side with
      | ExactInput =>
        (* we are given an exact input and are computing the output,
           which should be greater or equal to the limit *)
        uint128_ge result_amount limit_amount
      | ExactOutput =>
        (* we are given an exact output and are computing the input,
           which should be lower or equal to the limit *)
        uint128_ge limit_amount result_amount
      end
    end

(* computes the resultant amount for the given swap *)
let resultFor : Swap -> ResultOrError =
  fun (swap : Swap) =>
    match swap with
    | Swap maybe_pool direction exact_side exact_amount maybe_limit_amount after_fee =>
      match maybe_pool with
      | None =>
        let e = "MissingPool" in Error e
      | Some pool =>
        let maybe_amount = amountFor pool direction exact_side exact_amount after_fee in
        match maybe_amount with
        | None =>
          let e = "IntegerOverflow" in Error e
        | Some amount =>
          let within_limits = withinLimits amount maybe_limit_amount exact_side in
          match within_limits with
          | False =>
            let e = "RequestedRatesCannotBeFulfilled" in Error e
          | True =>
            Result pool amount
          end
        end
      end
    end

(* checks whether the given pool is empty based
   on where either of the token reserve amounts are zero *)
let poolEmpty : Pool -> Bool =
  fun (p : Pool) =>
    match p with
    | Pool x y =>
      let x_empty = builtin lt x one in
      let y_empty = builtin lt y one in
      orb x_empty y_empty
    end

contract HashSwap
(
  initial_owner : ByStr20,
  initial_fee : Uint256,
  inflation_rate : Uint256
)

with
  uint256_le initial_fee fee_denom
=>

field pools : Map ByStr20 Pool = Emp ByStr20 Pool
field balances : Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)
field total_contributions : Map ByStr20 Uint128 = Emp ByStr20 Uint128
field total_fees : Map ByStr20 Reward = Emp ByStr20 Reward
field total_rewards : Map ByStr20 Reward = Emp ByStr20 Reward
field output_after_fee : Uint256 = builtin sub fee_denom initial_fee
field owner : ByStr20 = initial_owner
field pending_owner : ByStr20 = zeroAddress
field staking_rate : Uint256 = inflation_rate

(* Fix LAUNCHER address in HEX *)
field launcher_address : ByStr20 = zeroAddress
field launcher_address_called : Bool = False
 


procedure ThrowIfExpired(deadline_block: BNum)
  current_block <- & BLOCKNUMBER;
  is_not_expired = builtin blt current_block deadline_block;
  match is_not_expired with
  | True =>
  | False =>
    e = { _exception : "TransactionExpired" };
    throw e
  end
end

procedure ThrowIfZero(number: Uint128)
  gt_zero = uint128_gt number zero;
  match gt_zero with
  | True =>
  | False =>
    e = { _exception : "InvalidParameter" };
    throw e
  end
end

procedure ThrowIfHusd(address : ByStr20)
  is_husd = builtin eq address husd_address;
  match is_husd with
  | False =>
  | True =>
    e = { _exception : "InvalidParameter" };
    throw e
  end
end

procedure ThrowUnlessSenderIsOwner()
  current_owner <- owner;
  is_owner = builtin eq _sender current_owner;
  match is_owner with
  | True =>
  | False =>
    e = { _exception : "InvalidSender" };
    throw e
  end
end

procedure Send(coins : Coins, to_address : ByStr20)
  match coins with
  | Coins denom amount =>
    match denom with
    | Husd husd =>
      msg_to_husd = { 
        _tag : "Transfer"; _recipient: husd; _amount: zero;
        to: to_address; amount: amount };
      msgs = oneMsg msg_to_husd;
      send msgs
    | Token token =>
      msg_to_token =  {
        _tag : "Transfer"; _recipient: token; _amount: zero;
        to: to_address; amount: amount
      };
      msgs = oneMsg msg_to_token;
      send msgs
    end
  end
end

procedure Receive(coins : Coins)
  match coins with
  | Coins denom amount =>
    match denom with
    | Husd husd =>
      msg_to_token = {
        _tag : "TransferFrom"; _recipient: husd; _amount: zero;
        from: _sender; to: _this_address; amount: amount
      };
      msgs = oneMsg msg_to_token;
      send msgs
    | Token token =>
      msg_to_token = {
        _tag : "TransferFrom"; _recipient: token; _amount: zero;
        from: _sender; to: _this_address; amount: amount
      };
      msgs = oneMsg msg_to_token;
      send msgs
    end
  end
end

procedure DoSwap(
  pool : Pool,
  token_address : ByStr20,
  input : Coins,
  output : Coins,
  input_from : ByStr20,
  output_to : ByStr20
)

  after_fee <- output_after_fee;
  match pool with
  | Pool x y => (* husd reserve, token reserve *)

    maybe_pool_reward <- total_rewards[token_address];
    match maybe_pool_reward with
    | None =>
    | Some pool_reward =>
      match pool_reward with
      | Reward transaction_fee sr pc =>
    
    
      (* update new pool balances *)
        match input with
        | Coins input_denom input_amount =>
          match output with
          | Coins output_denom output_amount =>
            match input_denom with
            | Husd husd =>
            
            (* Actual Input HUSD that goes in the pool is less than Input HUSD *)
            (* Rest of the HUSD goes in HEX as transaction fee *)
              some_actual_input = frac256 input_amount fee_denom after_fee;
              match some_actual_input with
              | None =>
              | Some actual_input => 
                new_pool =
                let new_x = builtin add x actual_input in
                let new_y = builtin sub y output_amount in
                Pool new_x new_y;
                pools[token_address] := new_pool;
              
                (* TRansaction fee difference between input_amount actual_input *)
                new_pool_reward = 
                  let new_transaction_fee = builtin sub input_amount actual_input in
                Reward new_transaction_fee sr pc;
                total_rewards[token_address] :=  new_pool_reward
                
              end
            | Token t =>
          
              (* Actual Output HUSD from the pool is more than Output amount HUSD *)
              (* Rest of the HUSD stay with HEX as transaction fee *)
              some_actual_output = frac256 output_amount after_fee fee_denom;
              match some_actual_output with
              | None =>
              | Some actual_output => 
                new_pool =
                  let new_x = builtin sub x actual_output in
                  let new_y = builtin add y input_amount in
                Pool new_x new_y;
                pools[token_address] := new_pool;
              
                (* TRansaction fee difference between actual_output output_amount *)
                new_pool_reward = 
                  let new_transaction_fee = builtin sub actual_output output_amount in
                Reward new_transaction_fee sr pc;
                total_rewards[token_address] :=  new_pool_reward
              end
            end 
          end
        end
      end
    end;

    (* do receive / send *)
    sending_from_self = builtin eq input_from _this_address;
    match sending_from_self with
    | True => (* don't do anything on internal send *)
    | False => Receive input (* accept the expected input *)
    end;

    sending_to_self = builtin eq output_to _this_address;
    match sending_to_self with
    | True => (* don't do anything on internal receive *)
    | False => Send output output_to (* send the expected output *)
    end;

    (* emit swap event *)
    e = {
      _eventname: "Swapped";
      pool: token_address; address: _sender;
      input: input; output: output
    };
    event e
  end
end

(* helper procedure to do swap twice, first to internally
   swap to an intermediate husd amount with pool0 and then
   to swap that husd with pool1 to the _sender *)
procedure DoSwapTwice(
  pool0 : Pool,
  token0_address : ByStr20,
  pool1 : Pool,
  token1_address : ByStr20,
  input_amount : Uint128,
  intermediate_amount : Uint128,
  output_amount : Uint128,
  recipient_address : ByStr20
)
  input = let token0 = Token token0_address in
    Coins token0 input_amount;
  intermediate = Coins husd intermediate_amount;
  output = let token1 = Token token1_address in
    Coins token1 output_amount;
  DoSwap
    pool0
    token0_address
    input
    intermediate
    _sender
    _this_address
  ;
  DoSwap
    pool1
    token1_address
    intermediate
    output
    _this_address
    recipient_address
end

procedure SwapUsingHUSD(
  token_address : ByStr20,
  direction : SwapDirection,
  exact_side : ExactSide,
  exact_amount : Uint128,
  limit_amount : Uint128,
  deadline_block : BNum,
  recipient_address : ByStr20
)
  ThrowIfExpired deadline_block;
  ThrowIfZero exact_amount;
  ThrowIfZero limit_amount;

  after_fee <- output_after_fee;
  maybe_pool <- pools[token_address];
  result =
    let option_limit_amount = Some {Uint128} limit_amount in
    let swap = Swap maybe_pool direction exact_side exact_amount option_limit_amount after_fee in
    resultFor swap;

  match result with
  | Error msg =>
    e = { _exception : msg };
    throw e
  | Result pool calculated_amount =>
    token = Token token_address;
    match exact_side with
    | ExactInput =>
      match direction with
      | HusdToToken =>
        input = Coins husd exact_amount;
        output = Coins token calculated_amount;
        DoSwap pool token_address input output _sender recipient_address
      | TokenToHusd =>
        input = Coins token exact_amount;
        output = Coins husd calculated_amount;
        DoSwap pool token_address input output _sender recipient_address
      end
    | ExactOutput =>
      match direction with
      | HusdToToken =>
        input = Coins husd calculated_amount;
        output = Coins token exact_amount;
        DoSwap pool token_address input output _sender recipient_address
      | TokenToHusd =>
        input = Coins token calculated_amount;
        output = Coins husd exact_amount;
        DoSwap pool token_address input output _sender recipient_address
      end
    end
  end
end



(* This transition is called ONE time *)
(* Only Launcher can call this transition *)
(* Owner of Launcher and HEX Should be SAME *)
(* Launcher Address is hardcoded in HEX *)
transition setLauncherAddress( sender_owner: ByStr20 )
  
  (* Owner of (sender)Launcher contract should be same as owner *)
  current_owner <- owner;
  launcherIsSender = builtin eq current_owner sender_owner;
  
  (* If register flag is false then set register_address field to sender *)
  address_flag <- launcher_address_called;
  match address_flag with
  | True =>
  | False =>
    (* launcher_address_called := true; *)
    launcher_address := _sender;
    e = {_eventname : "sponser_contract_address_set_forever"};
    event e
  end  
end

transition RecipientAcceptTransferFrom(
  initiator : ByStr20,
  sender : ByStr20,
  recipient : ByStr20,
  amount : Uint128
)
  is_valid_transfer_to_self =
    let self_triggered = builtin eq initiator _this_address in
    let is_transfer_to_self = builtin eq recipient _this_address in
    andb self_triggered is_transfer_to_self;

  match is_valid_transfer_to_self with
  | False =>
    e = { _exception : "InvalidInvocation" };
    throw e
  | True => (* noop *)
  end
end

transition TransferFromSuccessCallBack(
  initiator : ByStr20,
  sender : ByStr20,
  recipient : ByStr20,
  amount : Uint128
)
end

transition TransferSuccessCallBack(
  sender : ByStr20,
  recipient : ByStr20,
  amount : Uint128
)
end

transition SetFee(
  new_fee : Uint256
)
  ThrowUnlessSenderIsOwner;
  is_valid_fee = uint256_le new_fee fee_denom;
  match is_valid_fee with
  | False =>
    e = { _exception : "InvalidParameter" };
    throw e
  | True =>
    new_output_after_fee = builtin sub fee_denom new_fee;
    output_after_fee := new_output_after_fee;
    e = { _eventname: "FeeSet"; fee: new_fee };
    event e
  end
end

transition TransferOwnership(
  new_owner : ByStr20
)
  ThrowUnlessSenderIsOwner;
  existing_owner <- owner;
  new_owner_is_existing_owner = builtin eq new_owner existing_owner;
  match new_owner_is_existing_owner with
  | True =>
    e = { _exception : "InvalidParameter" };
    throw e
  | False =>
    pending_owner := new_owner
  end
end

transition AcceptPendingOwnership()
  new_owner <- pending_owner;
  sender_is_pending_owner = builtin eq _sender new_owner;
  match sender_is_pending_owner with
  | False =>
    e = { _exception : "InvalidSender" };
    throw e
  | True =>
    owner := new_owner;
    pending_owner := husd_address;
    e = { _eventname: "OwnershipTransferred"; owner: new_owner };
    event e
  end
end


(* Launcher is launching a NEW sponsor pool for trading on HEX *)
(* Only Launcher can call this transition *)
transition launchSponsorPool(
  token_address : ByStr20,
  husd_amount : Uint128,
  token_amount: Uint128
)

  launcher <- launcher_address;
  launcherIsSender = builtin eq launcher _sender;
  match launcherIsSender with
  | False =>
  | True =>
    
    (* Accept husd amount *)
    husd_in = Coins husd husd_amount;
    Receive husd_in;
    
    (* Accept token amount *)
    token = Token token_address;
    tokens_in = Coins token token_amount;
    Receive tokens_in;
    
    (* Create NEW pool record *)
    new_pool = Pool husd_amount token_amount;
    pools[token_address] := new_pool;
    e1 = { _eventname: "PoolCreated"; pool: token_address };
    event e1;

    balances[token_address][_sender] := husd_amount;
    total_contributions[token_address] := husd_amount;
    e2 = { _eventname: "Mint"; pool: token_address; address: _sender; amount: husd_amount };
    event e2

  end
end

(* HUSDSWAP: Add Liquidity either add liquidity or create a new pool *)
(* HASHSWAP: Add Liquidity only add liquidity to a pool *)
(* Adding a pool is done only by LAUNCHER *)
transition AddLiquidity(
  token_address : ByStr20,
  min_contribution_amount : Uint128,
  husd_amount: Uint128,
  max_token_amount : Uint128,
  deadline_block : BNum
)
  ThrowIfExpired deadline_block;
  ThrowIfHusd token_address;
  ThrowIfZero husd_amount;
  ThrowIfZero max_token_amount;

  token = Token token_address;

  (* accept all husd *)
  husds_in = Coins husd husd_amount;
  Receive husds_in;

  maybe_pool <- pools[token_address];
  match maybe_pool with
  | None => (* New pool can't be created. Maybe FUTURE UPDATE *)
  | Some pool =>
    match pool with
    | Pool x y => (* husd reserve, token reserve *)

      (* accept all husd *)
      husd_in = Coins husd husd_amount;
      Receive husd_in;
      (* dY = dX * Y / X *)
      (* dX is always the QA transferred *)
      
      (* Token_amount = husd_amount*(token_reserve)/(husd_reserve) *)
      maybe_result = frac husd_amount x y;
      match maybe_result with
      | None =>
        e = { _exception : "IntegerOverflow" };
        throw e
      | Some result =>
        delta_y = builtin add result one;
        maybe_total_contribution <- total_contributions[token_address];
        match maybe_total_contribution with
        | None =>
          e = { _exception : "MissingContributions" };
          throw e
        | Some total_contribution =>
          maybe_new_contribution = frac husd_amount x total_contribution;
          match maybe_new_contribution with
          | None =>
            e = { _exception : "IntegerOverflow" };
            throw e
          | Some new_contribution =>
            within_limits =
              let token_lte_max = uint128_le delta_y max_token_amount in
              let contribution_gte_max = uint128_ge new_contribution min_contribution_amount in
              andb token_lte_max contribution_gte_max;
            match within_limits with
            | False =>
              e = { _exception : "RequestedRatesCannotBeFulfilled" ; delta_y: delta_y };
              throw e
            | True =>
              tokens_in = Coins token delta_y;
              Receive tokens_in;

              new_pool =
                let new_x = builtin add x husd_amount in
                let new_y = builtin add y delta_y in
                Pool new_x new_y;
              pools[token_address] := new_pool;

              existing_balance <- balances[token_address][_sender];
              match existing_balance with
              | Some b =>
                new_balance = builtin add b new_contribution;
                balances[token_address][_sender] := new_balance
              | None =>
                balances[token_address][_sender] := new_contribution
              end;

              new_total_contribution = builtin add total_contribution new_contribution;
              total_contributions[token_address] := new_total_contribution;

              e = { _eventname: "Mint"; pool: token_address; address: _sender; amount: new_contribution };
              event e
            end
          end
        end
      end
    end
  end
end


(* This procedure calculates and pay the total share of fee and staking rewards
earned by a investor with share ratio and time ratio *)
procedure InvestorFeeRewards(
 token_address : ByStr20,
 shares : Uint128,
 total_shares : Uint128,
 option_entry_block : Option BNum,
 investor_address : ByStr20
)

  maybe_total_contribution <- total_contributions[token_address];
  match maybe_total_contribution with
  | None =>
  | Some total_contribution =>
    
    maybe_pool_rewards <- total_rewards[token_address];
    match maybe_pool_rewards with
    | None =>
    | Some pool_rewards =>
      match pool_rewards with
      | Reward transaction_fee staking_reward pool_block =>
        option_share_ratio = ratio shares total_shares;
        match option_share_ratio with
        | None => 
        | Some share_ratio =>
        
          current_block <- & BLOCKNUMBER;
          total_ratio = match option_entry_block with
          | None => share_ratio
          | Some entry_block =>
            let c_block = current_block in
            let time_ratio_num = builtin bsub current_block entry_block in
            let time_ratio_den = builtin bsub current_block pool_block in
            let time_ratio_i256 = builtin div time_ratio_num time_ratio_den in 
            let option_time_ratio_u128 = builtin to_uint128 time_ratio_i256 in
            match option_time_ratio_u128 with
            | None => zero
            | Some time_ratio_u128 =>
              builtin mul share_ratio time_ratio_u128
            end 
          end;
        
          (* GENERATE STAKING REWARDS EARNED SINCE LAST LIQUIDUTY EVENT *)
          (* Staking Reward are generated just before a redemption of investor token 
          This is the most efficient (Minimum transactions) way of 
          of disseminating staking rewards to pool liquidity as liquidity level changes after every redemttoin*)
          match staking_reward with
          | StakingReward staking_fee last_block =>
            time_since_last_liquidity_event_int256 = builtin bsub current_block last_block;
            maybe_time_since_last_liquidity_event = builtin to_uint128 time_since_last_liquidity_event_int256;
            match maybe_time_since_last_liquidity_event with
            | None =>
            | Some time_since_last_liquidity_event => 
              reward_rate <- staking_rate;
              maybe_curr_staking_fee_per_token = frac256 time_since_last_liquidity_event fee_denom reward_rate;
              match maybe_curr_staking_fee_per_token with
              | None =>
              | Some curr_staking_fee_per_token =>
              
                current_staking_fee = builtin mul curr_staking_fee_per_token total_contribution; 
                new_staking_reward = 
                  let new_staking_fee = builtin add staking_fee current_staking_fee in
                  let new_last_block = current_block in
                StakingReward new_staking_fee new_last_block;
          
                new_pool_rewards = Reward transaction_fee new_staking_reward pool_block;
                total_rewards[token_address] := new_pool_rewards;
            
                (* Ask HUSD to generate new staking fee for the pool *)
                generate_staking_rewards_msg = {_tag : "RemoveSponsorLiquidity"; 
                  _recipient : husd_address; _amount : zero; 
                  new_staking_rewards : current_staking_fee};
                msgs = oneMsg generate_staking_rewards_msg;
                send msgs
              end
            end
          end;
        
          (* Pay the transaction fee and staking reward *)
          maybe_new_pool_rewards <- total_rewards[token_address];
          match maybe_new_pool_rewards with      
          | None =>
          | Some new_pool_rewards =>
            match new_pool_rewards with
            | Reward new_transaction_fee new_staking_reward new_pool_block =>
              match new_staking_reward with
              | StakingReward new_staking_fee last_block =>
                (* Calculate Fee Reward *)
                investor_tf =  builtin mul total_ratio transaction_fee;
                investor_sf =  builtin mul total_ratio new_staking_fee;
                investor_total_fee = builtin add investor_tf investor_sf;
    
                (* Send money to investor *)
                investor_total_rewards = Coins husd investor_total_fee;
                Send investor_total_rewards investor_address
              end
            end
          end
          
          
        end
      end
    end
  end
end

(* To pay all fee and rewards for sponsors*)
(* This transition can only be called by Launcher *)
transition RedeemSponsorFeeRewards(
  token_address : ByStr20,
  sponsor_token : Uint128,
  total_sponsorship : Uint128,
  option_entry_block : Option BNum
)

  launcher <- launcher_address;
  launcherIsSender = builtin eq launcher _sender;
  match launcherIsSender with
  | False =>
  | True =>
    (* Calculate and Pay Fee and Rewards *)
    InvestorFeeRewards token_address sponsor_token total_sponsorship option_entry_block launcher
  end
end





transition RemoveSponsorLiquidity(
  token_address : ByStr20,
  husd_amount : Uint128,
  sponsor_address: ByStr20,
  influencer_wallet: ByStr20
)

  (* deadline block is not required  because amount is directly in husd and not lp tokens *)
  ThrowIfZero husd_amount;
  
  token = Token token_address;
  
  maybe_total_contribution <- total_contributions[token_address];
  match maybe_total_contribution with
  | None =>
    e = { _exception : "MissingPool" };
    throw e
  | Some total_contribution =>
    ThrowIfZero total_contribution;
    maybe_pool <- pools[token_address];
    match maybe_pool with
    | None =>
      e = { _exception : "MissingPool" };
      throw e
    | Some pool =>
      match pool with
      | Pool x y => (* husd reserve, token reserve *)
        maybe_contribution_amount = frac husd_amount x total_contribution;
        maybe_token_amount = frac husd_amount x y;
        match maybe_contribution_amount with
        | None =>
          e = { _exception : "IntegerOverflow" };
          throw e
        | Some contribution_amount =>
          match maybe_token_amount with
          | None =>
            e = { _exception : "IntegerOverflow" };
            throw e
          | Some token_amount => 
            
            existing_balance <- balances[token_address][_sender];
            match existing_balance with
            | None =>
              e = { _exception : "MissingBalance" };
              throw e
            | Some b =>
              new_pool =
                let new_x = builtin sub x husd_amount in
                let new_y = builtin sub y token_amount in
              Pool new_x new_y;

              is_pool_now_empty = poolEmpty new_pool;
              match is_pool_now_empty with
              | True =>
                (* clear pool entries when there is no more liquidity *)
                delete pools[token_address];
                delete balances[token_address];
                delete total_contributions[token_address]
              | False =>
                pools[token_address] := new_pool;
                new_balance = builtin sub b contribution_amount;
                balances[token_address][_sender] := new_balance;
                new_total_contribution = builtin sub total_contribution contribution_amount;
                total_contributions[token_address] := new_total_contribution
              end;

              husd_out = Coins husd husd_amount;
              tokens_out = Coins token token_amount;
              Send husd_out sponsor_address;
              Send tokens_out influencer_wallet;

              e = { _eventname: "Burnt"; pool: token_address; address: _sender; amount: contribution_amount };
              event e
            end
          end
        end
      end
    end
  end
end


transition RemoveLiquidity(
  token_address : ByStr20,
  contribution_amount : Uint128,
  min_husd_amount : Uint128,
  min_token_amount : Uint128,
  deadline_block : BNum
)
  ThrowIfExpired deadline_block;
  ThrowIfZero contribution_amount;
  ThrowIfZero min_husd_amount;
  ThrowIfZero min_token_amount;

  token = Token token_address;

  maybe_total_contribution <- total_contributions[token_address];
  match maybe_total_contribution with
  | None =>
    e = { _exception : "MissingPool" };
    throw e
  | Some total_contribution =>
    ThrowIfZero total_contribution;
    maybe_pool <- pools[token_address];
    match maybe_pool with
    | None =>
      e = { _exception : "MissingPool" };
      throw e
    | Some pool =>
      match pool with
      | Pool x y => (* husd reserve, token reserve *)
        maybe_husd_amount = frac contribution_amount total_contribution x;
        maybe_token_amount = frac contribution_amount total_contribution y;
        match maybe_husd_amount with
        | None =>
          e = { _exception : "IntegerOverflow" };
          throw e
        | Some husd_amount =>
          match maybe_token_amount with
          | None =>
            e = { _exception : "IntegerOverflow" };
            throw e
          | Some token_amount =>
            within_limits =
              let husd_ok = uint128_ge husd_amount min_husd_amount in
              let token_ok = uint128_ge token_amount min_token_amount in
              andb husd_ok token_ok;
            match within_limits with
            | False =>
              e = { _exception : "RequestedRatesCannotBeFulfilled" };
              throw e
            | True =>
              existing_balance <- balances[token_address][_sender];
              match existing_balance with
              | None =>
                e = { _exception : "MissingBalance" };
                throw e
              | Some b =>
                new_pool =
                  let new_x = builtin sub x husd_amount in
                  let new_y = builtin sub y token_amount in
                  Pool new_x new_y;

                is_pool_now_empty = poolEmpty new_pool;
                match is_pool_now_empty with
                | True =>
                  (* clear pool entries when there is no more liquidity *)
                  delete pools[token_address];
                  delete balances[token_address];
                  delete total_contributions[token_address]
                | False =>
                  pools[token_address] := new_pool;
                  new_balance = builtin sub b contribution_amount;
                  balances[token_address][_sender] := new_balance;
                  new_total_contribution = builtin sub total_contribution contribution_amount;
                  total_contributions[token_address] := new_total_contribution
                end;

                (* Pay back the principal amount *)
                husds_out = Coins husd husd_amount;
                tokens_out = Coins token token_amount;
                Send husds_out _sender;
                Send tokens_out _sender;
              
                (* Pay the Fee and Rewards *)
                (* No concept of time ratio for liquidity providers 
                as all liquidity providers are unique *)
                option_entry_block = None {BNum};
                InvestorFeeRewards token_address contribution_amount total_contribution option_entry_block _sender;

                e = { _eventname: "Burnt"; pool: token_address; address: _sender; amount: contribution_amount };
                event e
              end
            end
          end
        end
      end
    end
  end
end

transition SwapExactHUSDForTokens(
  token_address : ByStr20,
  husd_amount: Uint128,
  min_token_amount : Uint128,
  deadline_block : BNum,
  recipient_address : ByStr20
)
  direction = HusdToToken;
  exact_side = ExactInput;
  exact_amount = husd_amount;
  limit_amount = min_token_amount;

  SwapUsingHUSD
    token_address
    direction
    exact_side
    exact_amount
    limit_amount
    deadline_block
    recipient_address
end

transition SwapExactTokensForHUSD(
  token_address : ByStr20,
  token_amount : Uint128,
  min_husd_amount : Uint128,
  deadline_block : BNum,
  recipient_address : ByStr20
)
  direction = TokenToHusd;
  exact_side = ExactInput;
  exact_amount = token_amount;
  limit_amount = min_husd_amount;

  SwapUsingHUSD
    token_address
    direction
    exact_side
    exact_amount
    limit_amount
    deadline_block
    recipient_address
end

transition SwapHUSDForExactTokens(
  token_address : ByStr20,
  max_husd_amount: Uint128,
  token_amount : Uint128,
  deadline_block : BNum,
  recipient_address : ByStr20
)
  direction = HusdToToken;
  exact_side = ExactOutput;
  exact_amount = token_amount;
  limit_amount = max_husd_amount;

  SwapUsingHUSD
    token_address
    direction
    exact_side
    exact_amount
    limit_amount
    deadline_block
    recipient_address
end

transition SwapTokensForExactHUSD(
  token_address : ByStr20,
  max_token_amount : Uint128,
  husd_amount : Uint128,
  deadline_block : BNum,
  recipient_address : ByStr20
)
  direction = TokenToHusd;
  exact_side = ExactOutput;
  exact_amount = husd_amount;
  limit_amount = max_token_amount;

  SwapUsingHUSD
    token_address
    direction
    exact_side
    exact_amount
    limit_amount
    deadline_block
    recipient_address
end

transition SwapExactTokensForTokens(
  token0_address : ByStr20,
  token1_address : ByStr20,
  token0_amount : Uint128, (* the token0 amount to be sent in *)
  min_token1_amount : Uint128, (* min token0 amount that must be received for the txn to not revert *)
  deadline_block : BNum,
  recipient_address : ByStr20
)
  ThrowIfExpired deadline_block;
  ThrowIfZero token0_amount;
  ThrowIfZero min_token1_amount;

  after_fee <- output_after_fee;
  maybe_pool0 <- pools[token0_address];

  result0 =
    let direction = TokenToHusd in
    let exact_side = ExactInput in
    let limit_amount = None {Uint128} in
    let swap = Swap maybe_pool0 direction exact_side token0_amount limit_amount after_fee in
      resultFor swap;

  match result0 with
  | Error msg =>
    e = { _exception : msg };
    throw e
  | Result pool0 husd_intermediate_amount =>
    maybe_pool1 <- pools[token1_address];

    result1 =
      let direction = HusdToToken in
      let exact_side = ExactInput in
      let limit_amount = Some {Uint128} min_token1_amount in
      let swap = Swap maybe_pool1 direction exact_side husd_intermediate_amount limit_amount after_fee in
        resultFor swap;

    match result1 with
    | Error msg =>
      e = { _exception : msg };
      throw e
    | Result pool1 output_amount =>
      DoSwapTwice
        pool0
        token0_address
        pool1
        token1_address
        token0_amount
        husd_intermediate_amount
        output_amount
        recipient_address
    end
  end
end

transition SwapTokensForExactTokens(
  token0_address : ByStr20,
  token1_address : ByStr20,
  max_token0_amount : Uint128, (* the max token0 amount that may be sent in before the txn will revert *)
  token1_amount : Uint128, (* token1 amount to be received *)
  deadline_block : BNum,
  recipient_address : ByStr20
)
  ThrowIfExpired deadline_block;
  ThrowIfZero max_token0_amount;
  ThrowIfZero token1_amount;

  after_fee <- output_after_fee;
  maybe_pool1 <- pools[token1_address];

  result1 =
    let direction = HusdToToken in
    let exact_side = ExactOutput in
    let limit_amount = None {Uint128} in
    let swap = Swap maybe_pool1 direction exact_side token1_amount limit_amount after_fee in
      resultFor swap;

  match result1 with
  | Error msg =>
    e = { _exception : msg };
    throw e
  | Result pool1 husd_intermediate_amount =>
    maybe_pool0 <- pools[token0_address];

    result0 =
      let direction = TokenToHusd in
      let exact_side = ExactOutput in
      let limit_amount = Some {Uint128} max_token0_amount in
      let swap = Swap maybe_pool0 direction exact_side husd_intermediate_amount limit_amount after_fee in
        resultFor swap;

    match result0 with
    | Error msg =>
      e = { _exception : msg };
      throw e
    | Result pool0 input_amount =>
      DoSwapTwice
        pool0
        token0_address
        pool1
        token1_address
        input_amount
        husd_intermediate_amount
        token1_amount
        recipient_address
    end
  end
end